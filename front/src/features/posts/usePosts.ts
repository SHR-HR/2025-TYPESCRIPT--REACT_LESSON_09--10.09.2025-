// Импорт необходимых хуков и функций из React
import { useState, useEffect } from 'react';
// Импорт API клиента для выполнения HTTP запросов
import { apiClient } from '@/api/http';
// Импорт типов данных для постов
import type { Post, PostPayload } from '@/shared/types';

// Функция для получения текущей даты и времени в формате ISO
const nowISO = () => new Date().toISOString();

// Моковые данные поста для использования при недоступности API
const MOCK_POST: Post = {
  id: 'mock-1', // Уникальный идентификатор мокового поста
  title: 'Мок пост', // Заголовок мокового поста
  content: 'API недоступно, показаны тестовые данные', // Содержание мокового поста
  author: 'demo', // Автор мокового поста
  created_at: nowISO(), // Дата создания в формате ISO
  updated_at: nowISO(), // Дата обновления в формате ISO
};

// Пользовательский хук для работы с постами
export const usePosts = () => {
  // Состояние для хранения массива постов
  const [posts, setPosts] = useState<Post[]>([]);
  // Состояние для отслеживания процесса загрузки
  const [loading, setLoading] = useState(false);
  // Состояние для хранения ошибок
  const [error, setError] = useState<string | null>(null);
  // Состояние для хранения лимита количества постов
  const [limit, setLimit] = useState(3);

  // Функция для загрузки постов с сервера
  const fetchPosts = async () => {
    setLoading(true); // Установка состояния загрузки в true
    setError(null); // Сброс предыдущих ошибок
    try {
      // Выполнение GET запроса для получения постов
      const { data } = await apiClient.get<Post[]>('', {
        params: {
          _limit: limit, // Параметр лимита количества постов
          _start: 0 // Параметр начальной позиции
        }
      });
      setPosts(data); // Обновление состояния с полученными данными
    } catch (err) {
      // Обработка ошибки при загрузке
      setError(err instanceof Error ? err.message : 'Ошибка загрузки постов');
      // Установка моковых данных при ошибке
      setPosts([MOCK_POST]);
    } finally {
      setLoading(false); // Завершение процесса загрузки
    }
  };

  // Функция для создания нового поста
  const createPost = async (data: PostPayload) => {
    try {
      setError(null); // Сброс предыдущих ошибок
      // Выполнение POST запроса для создания поста
      const { data: created } = await apiClient.post<Post>('', data);
      // Добавление созданного поста в начало списка
      setPosts(prev => [created, ...prev]);
      return created; // Возврат созданного поста
    } catch (err) {
      // Обработка ошибки при создании
      setError(err instanceof Error ? err.message : 'Ошибка создания поста');
      // Создание мокового поста при ошибке
      const mock: Post = {
        id: `mock-${Date.now()}`, // Уникальный ID на основе timestamp
        created_at: nowISO(), // Текущая дата создания
        updated_at: nowISO(), // Текущая дата обновления
        ...data // Распаковка переданных данных
      };
      // Добавление мокового поста в начало списка
      setPosts(prev => [mock, ...prev]);
      return mock; // Возврат мокового поста
    }
  };

  // Функция для обновления существующего поста
  const updatePost = async (id: Post['id'], patch: Partial<PostPayload>) => {
    try {
      setError(null); // Сброс предыдущих ошибок
      // Выполнение PUT запроса для обновления поста
      const { data: updated } = await apiClient.put<Post>(`/${id}`, patch);
      // Обновление поста в массиве
      setPosts(prev => prev.map(p => (p.id === id ? updated : p)));
      return updated; // Возврат обновленного поста
    } catch (err) {
      // Обработка ошибки при обновлении
      setError(err instanceof Error ? err.message : 'Ошибка обновления поста');
      // Локальное обновление поста при ошибке
      setPosts(prev => prev.map(p => (p.id === id ? {
        ...p, // Сохранение существующих данных
        ...patch, // Применение обновлений
        updated_at: nowISO() // Обновление времени изменения
      } : p)));
    }
  };

  // Функция для удаления поста
  const deletePost = async (id: Post['id']) => {
    try {
      setError(null); // Сброс предыдущих ошибок
      // Выполнение DELETE запроса для удаления поста
      await apiClient.delete<void>(`/${id}`);
      // Удаление поста из массива
      setPosts(prev => prev.filter(p => p.id !== id));
    } catch (err) {
      // Обработка ошибки при удалении
      setError(err instanceof Error ? err.message : 'Ошибка удаления поста');
      // Локальное удаление поста при ошибке
      setPosts(prev => prev.filter(p => p.id !== id));
    }
  };

  // Функция для увеличения лимита постов на 1
  const incrementLimit = () => setLimit(prev => prev + 1);

  // Функция для установки конкретного значения лимита
  const setLimitTo = (n: number) => setLimit(n);

  // Эффект для автоматической загрузки постов при изменении лимита
  useEffect(() => {
    fetchPosts(); // Вызов функции загрузки постов
  }, [limit]); // Зависимость от значения лимита

  // Возврат объекта с состояниями и функциями для использования в компонентах
  return {
    posts, // Массив постов
    loading, // Флаг загрузки
    error, // Сообщение об ошибке
    limit, // Текущий лимит
    fetchPosts, // Функция загрузки постов
    createPost, // Функция создания поста
    updatePost, // Функция обновления поста
    deletePost, // Функция удаления поста
    incrementLimit, // Функция увеличения лимита
    setLimitTo, // Функция установки лимита
  };
};

/* ================= ПОЯСНЕНИЯ К КОММЕНТАРИЯМ ================= */

/*
1. Пользовательский хук (Custom Hook):
   usePosts - это пользовательский хук, который инкапсулирует логику работы с постами.
   Позволяет переиспользовать логику в разных компонентах.

2. Состояния (useState):
   - posts: хранение массива постов
   - loading: индикатор процесса загрузки
   - error: хранение сообщений об ошибках
   - limit: управление количеством загружаемых постов

3. Асинхронные операции:
   Все функции (fetchPosts, createPost, updatePost, deletePost) являются асинхронными
   и используют async/await для работы с промисами.

4. Обработка ошибок:
   try/catch блоки в каждой функции для graceful error handling.
   При ошибках показываются моковые данные вместо падения приложения.

5. Моковые данные:
   MOCK_POST используется как fallback при недоступности API.
   Обеспечивает работу приложения даже при проблемах с сервером.

6. Параметры запросов:
   _limit - ограничение количества возвращаемых постов
   _start - начальная позиция для пагинации (всегда 0 в данном случае)

7. Обновление состояния:
   setPosts используется для обновления массива постов после каждой операции.
   Функциональные обновления (prev => ...) гарантируют актуальность предыдущего состояния.

8. Эффект (useEffect):
   Автоматическая загрузка постов при изменении лимита.
   Зависимость [limit] ensures эффект выполняется при каждом изменении limit.

9. Типизация TypeScript:
   Полная типизация всех параметров и возвращаемых значений.
   Использование generic types в useState и apiClient.

10. CRUD операции:
    Полный набор операций: Create, Read, Update, Delete.

11. Оптимистичные обновления:
    При ошибках сети выполняются локальные обновления состояния для лучшего UX.

12. Возвращаемый объект:
    Хук возвращает объект со всеми состояниями и функциями для работы с постами.

13. Формат дат:
    Использование ISO формата для дат создания и обновления.

14. Уникальные идентификаторы:
    Для моковых постов используются уникальные ID на основе timestamp.

15. Очистка ошибок:
    setError(null) вызывается перед каждой операцией для сброса предыдущих ошибок.

16. finally блок:
    В fetchPosts гарантирует, что loading всегда устанавливается в false после завершения.

17. Распаковка данных:
    Использование spread оператора (...) для merging объектов.

18. Проверка типа ошибок:
    err instanceof Error обеспечивает безопасный доступ к message.

19. Функциональные обновления:
    Использование функций в setLimit(prev => prev + 1) для гарантии актуальности состояния.

20. Мемоизация:
    Хук не использует useCallback для функций, так как они не передаются в зависимости эффектов.
*/


// =============================================================================
// КОНЕЦ ФАЙЛА
// =============================================================================



