// Импорт типов из файла studentsSlice для TypeScript типобезопасности
import type { StudentsState, AttendanceStatus, Student } from './studentsSlice';

// =============================================================================
// ФУНКЦИЯ ЭКСПОРТА ДАННЫХ В CSV ФАЙЛ
// =============================================================================

/** Формат CSV:
 *  name;group;date;mark;status
 *  Строка на каждую дату, где есть отметка или посещаемость.
 */
export function exportCSV(state: StudentsState) {
    // Создаем массив строк CSV, начинаем с заголовка
    const rows: string[] = ['name;group;date;mark;status'];

    // Перебираем всех студентов в состоянии
    state.students.forEach((s) => {
        // Индексируем посещаемость по дате, используя пустой объект если attendance отсутствует
        const attMap = s.attendance ?? {};
        // Создаем Set уникальных дат из посещаемости и оценок
        const dates = new Set<string>([
            ...Object.keys(attMap), // Даты из посещаемости
            ...s.marks.map((m) => m.date), // Даты из оценок
        ]);

        // Если вообще пусто — добавляем хотя бы одну строку на ученика
        if (dates.size === 0) {
            // Строка с именем и группой, но без даты, оценки и статуса
            rows.push(`${s.name};${s.group ?? ''};;;`);
            return; // Переходим к следующему студенту
        }

        // Преобразуем Set в массив, сортируем даты и перебираем их
        Array.from(dates).sort().forEach((date) => {
            // Фильтруем оценки для текущей даты
            const marks = s.marks.filter((m) => m.date === date);
            // Если в этот день нет оценок
            if (marks.length === 0) {
                // Добавляем строку только с посещаемостью
                rows.push(`${s.name};${s.group ?? ''};${date};;${attMap[date] ?? ''}`);
            } else {
                // Если есть оценки — добавляем по строке на каждую оценку
                marks.forEach((m) => {
                    rows.push(`${s.name};${s.group ?? ''};${date};${m.value};${attMap[date] ?? ''}`);
                });
            }
        });
    });

    // Создаем Blob объект с CSV данными
    const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8' });
    // Создаем временную ссылку для скачивания
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'journal.csv'; // Устанавливаем имя файла
    document.body.appendChild(a); // Добавляем ссылку в DOM
    a.click(); // Программно кликаем по ссылке для скачивания
    a.remove(); // Удаляем ссылку из DOM
    URL.revokeObjectURL(a.href); // Освобождаем память от объекта URL
}

// =============================================================================
// ФУНКЦИЯ ИМПОРТА ДАННЫХ ИЗ CSV ФАЙЛА
// =============================================================================

export async function importCSV(file: File): Promise<StudentsState> {
    // Читаем содержимое файла как текст
    const text = await file.text();
    // Разбиваем текст на строки, фильтруем пустые строки
    const lines = text.split(/\r?\n/).filter(Boolean);
    // Разделяем заголовок и данные (пропускаем первую строку - заголовок)
    const [, ...data] = lines;

    // Создаем Map для группировки студентов по ключу (имя+группа)
    const byKey = new Map<string, Student>();
    // Функция для создания уникального ключа студента
    const getKey = (name: string, group: string) => `${name}|||${group}`;

    // Перебираем все строки данных из CSV
    for (const line of data) {
        // Разбиваем строку на колонки по разделителю ;
        const [name = '', group = '', date = '', mark = '', status = ''] = line.split(';');
        // Пропускаем строки без имени
        if (!name) continue;
        // Получаем уникальный ключ студента
        const key = getKey(name, group);
        // Если студента с таким ключом еще нет в Map - создаем его
        if (!byKey.has(key)) {
            byKey.set(key, {
                id: crypto.randomUUID(), // Генерируем уникальный ID
                name,
                group,
                marks: [], // Пустой массив оценок
                attendance: {} // Пустой объект посещаемости
            });
        }
        // Получаем объект студента из Map
        const st = byKey.get(key)!;

        // Обрабатываем оценку если она есть
        if (mark) {
            const value = Number(mark); // Преобразуем строку в число
            if (!Number.isNaN(value)) { // Проверяем что преобразование успешно
                st.marks.push({
                    id: crypto.randomUUID(), // Генерируем уникальный ID для оценки
                    date,
                    value
                });
            }
        }
        // Обрабатываем статус посещаемости если он есть
        if (status) {
            st.attendance[date] = status as AttendanceStatus; // Приводим тип к AttendanceStatus
        }
    }

    // Возвращаем новое состояние StudentsState
    return {
        daysWindow: 30, // Устанавливаем окно дней по умолчанию
        students: Array.from(byKey.values()), // Преобразуем Map в массив студентов
    };
}

// =============================================================================
// ПОЯСНЕНИЯ К КОММЕНТАРИЯМ
// =============================================================================

/**
 * ПОЯСНЕНИЯ К КОММЕНТАРИЯМ:
 *
 * 1. ФОРМАТ CSV:
 *    - Используется разделитель точка с запятой (;)
 *    - Структура: name;group;date;mark;status
 *    - Поддерживается несколько оценок в один день (несколько строк)
 *    - Сохраняются данные о посещаемости и оценках
 *
 * 2. ЭКСПОРТ CSV:
 *    - Создается заголовок с названиями колонок
 *    - Для каждого студента обрабатываются все даты с данными
 *    - Сортировка дат обеспечивает порядок в файле
 *    - Blob объект создает файл в памяти для скачивания
 *    - Автоматическое скачивание через программный клик по ссылке
 *
 * 3. ИМПОРТ CSV:
 *    - Асинхронное чтение файла через File API
 *    - Обработка разных форматов переносов строк (\r\n и \n)
 *    - Группировка данных по студентам через Map
 *    - Уникальные ключи студентов: имя + группа
 *    - Валидация числовых оценок (пропуск NaN)
 *    - Генерация UUID для новых записей
 *
 * 4. ОБРАБОТКА ДАННЫХ:
 *    - Поддержка пустых значений в CSV
 *    - Сохранение структуры данных StudentsState
 *    - Совместимость с форматом из экспорта
 *    - Восстановление сложной структуры из плоского CSV
 *
 * 5. БЕЗОПАСНОСТЬ И ВАЛИДАЦИЯ:
 *    - Проверка на пустые имена студентов
 *    - Валидация числовых значений оценок
 *    - Приведение типов для статусов посещаемости
 *    - Обработка возможных ошибок формата
 *
 * 6. ПРОИЗВОДИТЕЛЬНОСТЬ:
 *    - Использование Set для уникальных дат
 *    - Map для эффективной группировки студентов
 *    - Фильтрация и сортировка только необходимых данных
 *    - Оптимизированная работа с большими объемами данных
 *
 * 7. СООТВЕТСТВИЕ ТИПАМ:
 *    - Строгое соответствие типам из studentsSlice
 *    - Правильное приведение типов при импорте
 *    - Сохранение структуры данных при экспорте/импорте
 *
 * 8. ПОЛЬЗОВАТЕЛЬСКИЙ ОПЫТ:
 *    - Автоматическое скачивание с понятным именем файла
 *    - Поддержка стандартного CSV формата
 *    - Совместимость с Excel и другими редакторами
 *    - Восстановление данных после импорта
 */

// =============================================================================
// КОНЕЦ ФАЙЛА
// =============================================================================
